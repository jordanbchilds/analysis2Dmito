{
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
prior = output[[root]]$PRIOR
postpred = output[[root]]$POSTPRED
class = colMeans(output[[root]]$CLASSIF)
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
op = par(mfrow=c(3,3), mar=c(4.1,3,1,2), cex.main=1.5, cex.lab=1.5, cex.axis=1.5)
postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
title(main=root, line=-1, outer=TRUE)
par(op)
}
}
}
postpred
postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
1:0
#'
#' postPlot(post=infOut$POST, prior=infOut$PRIOR, classifs=class, postpred=infOut$POSTPRED,
#'          dataMats=data_mat)
#'
#' @importFrom data.table fread
#' @importFrom stats density
#' @importFrom graphics lines
#' @importFrom graphics points
#'
#' @export
postPlot = function(post,
prior = NULL,
postpred,
priorpred = NULL,
dataMats,
classifs,
var.names = c("mu_m",
"tau_m",
"tau_norm",
"mu_c",
"tau_c",
"probdiff",
"m",
"c"),
xlabs = NULL,
mitoPlot_xlab="",
mitoPlot_ylab="",
main_title="",
chains=1,
...) {
if (!is.null(xlabs)) {
if (is.null(names(xlabs)))
names(xlabs) = var.names
} else {
xlabs = var.names
names(xlabs) = var.names
}
if (is.character(post)) {
if (file.exists(post)) {
post = data.table::fread(post, header = TRUE)
post = as.data.frame(post)
} else {
stop(paste0("The file, ", post, ", does not exist."))
}
}
if (is.character(postpred)) {
if (file.exists(postpred)) {
postpred = data.table::fread(postpred, header = TRUE)
postpred = as.data.frame(postpred)
} else {
stop(paste0("The file, ", postpred, ", does not exist."))
}
}
if (!is.null(prior)) {
if (is.character(prior)) {
if (file.exists(prior)) {
prior = data.table::fread(prior, header = TRUE)
prior = as.data.frame(prior)
} else {
message(paste0("The file, ", prior, ", does not exist."))
}
}
}
if (!is.null(priorpred)) {
if (is.character(priorpred)) {
if (file.exists(priorpred)) {
priorpred = data.table::fread(priorpred, header = TRUE)
priorpred = as.data.frame(priorpred)
} else {
message(paste0("The file, ", priorpred, ", does not exist."))
}
}
}
colnames = colnames(post)
for (var in var.names) {
if (sum(grepl(paste0(var, "\\["), colnames)) > 0) {
post_var = post[, grepl(paste0(var, "\\["), colnames)]
post_dens = list()
priorParent = prior[, paste0(var, "_pred")]
priorParent_dens = stats::density(priorParent)
postParent = post[, paste0(var, "_pred")]
postParent_dens = stats::density(postParent)
xlim_varMin = min(postParent_dens$x)
xlim_varMax = max(postParent_dens$x)
ylim_var = max(postParent_dens$y)
for (param in colnames(post_var)) {
post_dens[[paste(param)]] = stats::density(post_var[,param])
ylim_var = max(c(ylim_var, post_dens[[param]]$y))
xlim_varMax = max(c(xlim_varMax, post_dens[[param]]$x))
xlim_varMin = min(c(xlim_varMin, post_dens[[param]]$x))
}
plot(
NA,
main = "",
xlab = xlabs[var],
ylab = "",
xlim = c(xlim_varMin, xlim_varMax),
ylim = c(0, ylim_var),
...
)
graphics::lines(
priorParent_dens,
col = analysis2Dmito::alphaPink(1.0),
lty = 4,
...
)
graphics::lines(
postParent_dens,
col = analysis2Dmito::alphaGreen(1.0),
lty = 4,
...
)
ind = grep(paste0(var, "\\["), colnames, value = TRUE)
ind = gsub("\\]", "", gsub(paste0(var, "\\["), "", ind))
max_ind = max(as.numeric(ind))
for (param in colnames(post_var)[paste0(var, "[", max_ind, "]") != colnames(post_var)]) {
graphics::lines(
post_dens[[param]],
col = analysis2Dmito::alphaGreen(0.4),
...
)
}
graphics::lines(
post_dens[[paste0(var, "[", max_ind, "]")]],
col = analysis2Dmito::alphaGreen(1.0),
...
)
} else {
post_den = stats::density(post[, paste(var)])
prior_den = stats::density(prior[, paste(var)])
xlims = range(c(prior_den$x, post_den$x))
yMax = max(c(prior_den$y, post_den$y))
plot(
NA,
xlim = xlims,
ylim = c(0, yMax),
xlab = xlabs[var],
ylab = "",
main = "",
...
)
graphics::lines(
prior_den,
col = analysis2Dmito::alphaPink(1.0),
...
)
graphics::lines(
post_den,
col = analysis2Dmito::alphaGreen(1.0),
...
)
}
}
xlims = range((c(dataMats$ctrl[, 1], dataMats$pts[, 1])))
ylims = range((c(dataMats$ctrl[, 2], dataMats$pts[, 2])))
plot(
NULL,
xlab = mitoPlot_xlab,
ylab = mitoPlot_ylab,
main = "",
xlim = xlims,
ylim = ylims,
...
)
graphics::points(
dataMats$ctrl,
pch = 20,
col = analysis2Dmito::alphaBlack(0.05),
...
)
graphics::points(
dataMats$pts,
pch = 20,
col = analysis2Dmito::classcols(classifs),
...
)
for( i in 1:chains ){
chain_ind = ( (i-1)*1000 + 1 ):( i*1000 )
graphics::lines(
postpred[chain_ind,"mitochan"],
postpred[chain_ind,"lwrNorm"],
lty = 2,
col = analysis2Dmito::alphaGreen(1.0),
...
)
graphics::lines(
postpred[chain_ind,"mitochan"],
postpred[chain_ind,"medNorm"],
lty = 1,
col = analysis2Dmito::alphaGreen(1.0),
...
)
graphics::lines(
postpred[chain_ind,"mitochan"],
postpred[chain_ind,"uprNorm"],
lty = 2,
col = analysis2Dmito::alphaGreen(1.0),
...
)
}
}
postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
# ------ postPlot
pdf(file.path("PDF", "postPlot.pdf"), width=13, height=8)
{
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
prior = output[[root]]$PRIOR
postpred = output[[root]]$POSTPRED
class = colMeans(output[[root]]$CLASSIF)
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
op = par(mfrow=c(3,3), mar=c(4.1,3,1,2), cex.main=1.5, cex.lab=1.5, cex.axis=1.5)
postPlot(post=post, prior=prior,
postpred=postpred,
classifs=class,
dataMats = dataMats,
var.names=c("mu_m", "tau_m", "tau_norm", "mu_c", "tau_c", "probdiff", "m", "c"),
mitoPlot_xlab=paste0("log(", mitochan, ")"),
mitoPlot_ylab=paste0("log(", chan, ")"))
title(main=root, line=-1, outer=TRUE)
par(op)
}
}
}
dev.off()
dev.off()
{
op = par(mfrow=c(1,1), mar=c(6,6,6,3), cex.main=2, cex.axis=1.5, cex.lab=2)
for( root in names(output) ){
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
class = apply(output[[root]]$CLASSIF, 2, mean)
post = output[[root]]$POST
pi_est = round(mean( post[,"probdiff"] ), 3)
postpred = output[[root]]$POSTPRED
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
analysis2Dmito::classif_plot(dataMats=dataMats,
postpred=NULL,
classifs=class,
xlab=mitochan,
ylab=chan)
title(main=bquote(atop(.(pat),"nPat:"~.(nrow(dataMats$pts))*",   E("*pi*"|X)="*.(pi_est))))
}
par(op)
}
}
}
# ------ Classif plot
pdf(file.path("PDF", "classif.pdf"), width=13, height=8)
{
op = par(mfrow=c(1,1), mar=c(6,6,6,3), cex.main=2, cex.axis=1.5, cex.lab=2)
for( root in names(output) ){
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
class = apply(output[[root]]$CLASSIF, 2, mean)
post = output[[root]]$POST
pi_est = round(mean( post[,"probdiff"] ), 3)
postpred = output[[root]]$POSTPRED
dataMats = analysis2Dmito::getData_mats(data=data,
channels=c(mitochan, chan),
ctrlID=ctrlIDs,
pts=pat)
analysis2Dmito::classif_plot(dataMats=dataMats,
postpred=NULL,
classifs=class,
xlab=mitochan,
ylab=chan)
title(main=bquote(atop(.(pat),"nPat:"~.(nrow(dataMats$pts))*",   E("*pi*"|X)="*.(pi_est))))
}
par(op)
}
}
}
dev.off()
pdf(file.path("PDF", "classif.pdf"), width=13, height=8)
{
op = par( mfrow = c(1, 1), mar = c(6, 6, 6, 3), cex.main = 2, cex.axis = 1.5, cex.lab = 2)
for (chan in channels) {
for (pat in pts) {
root = paste0(chan, "_", pat)
class = apply(output[[root]]$CLASSIF, 2, mean)
post = output[[root]]$POST
pi_est = round(mean(post[, "probdiff"]), 3)
postpred = output[[root]]$POSTPRED
dataMats = analysis2Dmito::getData_mats(
data = data,
channels = c(mitochan, chan),
ctrlID = ctrlIDs,
pts = pat
)
analysis2Dmito::classif_plot(
dataMats = dataMats,
postpred = NULL,
classifs = class,
xlab = mitochan,
ylab = chan
)
title(main = bquote(atop(
.(pat), "nPat:" ~ .(nrow(dataMats$pts)) * ",   E(" * pi * "|X)=" * .(pi_est)
)))
}
par(op)
}
}
dev.off()
?Rhat
# --- Calculating ESS
install.packges("coda")
library("coda")
?effectiveSize
coda::effectiveSize
?coda::effectiveSize
# --- Calculating ESS
install.packges("coda")
library("coda")
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]
ess = coda::effectiveSize( post )
}
}
ess
print(1)
1+1
root
post
channels
pts
root
output
names(output)
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]
ess = coda::effectiveSize( post )
}
}
post
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess = coda::effectiveSize( post )
}
}
ess
post
coda::effectiveSize( post )
as.mcmc.list(post)
effectiveSize
effectiveSize()
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess = coda::effectiveSize( as.mcmc.list(post) )
}
}
# --- Calculating ESS
install.packges("coda")
library("coda")
coda::effectiveSize( post )
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess = coda::effectiveSize( post )
}
}
ess
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess_list[[root]] = coda::effectiveSize( post )
print(post)
print(ess_list[[root]])
}
}
ess_list = list()
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess_list[[root]] = coda::effectiveSize( post )
print(post)
print(ess_list[[root]])
}
}
ess_list = list()
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess_list[[root]] = coda::effectiveSize( post )
print(root)
print(ess_list[[root]])
}
}
install.packages("mcmcse")
library("coda")
library("mcmcse")
?multiESS
ess_list = list()
multiESS = list()
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess_list[[root]] = coda::effectiveSize( post )
multiESS[[root]] = mcmcse::multiESS( post )
print(root)
print(multiESS[[root]])
print(ess_list[[root]])
}
}
multiESS
for( chan in channels ){
for( pat in pts ){
root = paste0(chan, "_", pat)
post = output[[root]]$POST
ess_list[[root]] = coda::effectiveSize( post )
multiESS[[root]] = mcmcse::multiESS( post )
print(root)
print(multiESS[[root]])
print(ess_list[[root]])
}
}
(ess = coda::effectiveSize( output$POST ))
list.files()
file.edit("./R/postPlot.R")
file.edit("./R/list_saver.R")
file.edit("example_analysis.R")
file.edit("./R/stan_inference.R")
list.files()
list.files("./R")
file.edit("./R/stan_inference.R")
edit.file("./R/getData")
edit.file("./R/getData.R")
file.edit("./R/getData.R")
file.remove("./R/getData/R")
getwd()
file.remove("./R/getData.R")
file.edit("./R/getData_mats.R")
file.edit("./R/get_exampleData.R")
urlfile = "https://raw.githubusercontent.com/jordanbchilds/AV_mitocyto/main/Data_prepped.csv"
rawData = readr::read_delim(url(urlfile))
head(rawData)
mitochan = "VDAC"
channels = c("NDUFB8", "CYB", "MTCO1")
rawData = rawData[,c("ID", "patient_id", mitochan, channels)]
colnames(rawData) = c("fibreID", "sampleID", mitochan, channels)
data = tidyr::pivot_longer(rawData, cols=c(mitochan, channels), names_to="Channel")
head(data)
head(rawData)
?pivot_longer
roxygen2()
file.edit("./R/postPlot.R")
file.edit("./R/classcols.R")
?sampling
