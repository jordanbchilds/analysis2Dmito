% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/getData_mats.R
\name{getData_mats}
\alias{getData_mats}
\title{Data preparation for \link{inference}.}
\usage{
getData_mats(
  data,
  channels,
  ctrlID = NULL,
  pts = NULL,
  ctrlOnly = FALSE,
  getIndex = TRUE
)
}
\arguments{
\item{data}{A data.frame object of the protein expression data. See details
for the format the data should be in.}

\item{channels}{A vector of strings or a single string containing the
channels which will form the columns of the returned matrices.}

\item{ctrlID}{A character vector denoting the IDs for the control samples in
the \code{sampleID} column of data. If this is not given the data must have a
\code{sbjType} column specifying which samples are \code{control} or \code{patient}.}

\item{pts}{A vector of subject names or a single subject name, whose
expression levels are to be returned. The default value is \code{NULL}, if this is
the case the protein expression levels for all samples within the dataset are
returned.}

\item{ctrlOnly}{A boolean variable indicating whether to return only control
subject data, the default is \code{FALSE.}}

\item{getINDEX}{A boolean parameter. If \code{TRUE}, a vector is returned for both
the control and patient data matrices indicating which observations come the
same sample.}
}
\value{
If \code{ctrlOnly=TRUE} and \code{getIndex=FALSE} then a matrix is returned of
just the control sample fibre expression otherwise a list is returned
containing data matrices and index vectors. The columns of the data matrices
correspond to the channels requested, in the order they are given in \code{channels}
argument. The possible elements in the list are:
\itemize{
\item \code{ctrl} : The control sample data matrix.
\item \code{pts} : The patient sample data matrix.
\item \code{indexCtrl} : A vector of indexes for the control data matrix, where the i-th
element corresponds to the i-th row of the matrix, indicating which
observations belong to the same sample.
\item \code{indexPts} : A vector of indexes for the patient data matrix, where the i-th
element corresponds to the i-th row of the matrix, indicating which
observations belong to the same sample.
}

The indexes, in the \code{indexPts} and \code{indexCtrl} vectors, range from 1 to the total
number of control samples in the data . For example, if four control samples are in the dataset (and their
sample IDs are passed to the \code{ctrlID} argument) then observations with an index
of 1 will be associated with the first element in \code{ctrlID}, an index of 2 will
be observations from the second element in \code{ctrlID} etc. Continuing this example, the patient indexes
will start at 5 (as there are four control sample) and will increase
similarly depending on the number of patient samples being outputted, which
can be controlled by the \code{pts} argument. If the data is then going to be used
in with the \link{stan_inference} function, then there should only
be one patient sample.
}
\description{
The function aggregates the data into the form needed for
\link{stan_inference}. To be able to do this the data passed to the
function must be in a specific form, see details for more info.
}
\details{
The data frame passed to the function must be in long form and have
the following columns; \code{Value}, \code{Channel}, \code{sampleID} and \code{fibreID}. Where
'Value' is the protein expression level, 'Channel' is the protein or channel
that the value expresses, \code{sampleID} is the identifying name associated with
the tissue sample on which the measurement was made and \code{fibreID} is the
fibre identification from that sample. Other columns can be present but are
not needed. One column which is helpful is a column identifying which samples
are from control subjects and which are from patients. For this to be used
the column must be called \code{sbjType} and the each value must be labelled
\code{control} or \code{patient}. To be able to transform the data into long form, we
suggest using the \link{tidyverse} package and the \link[tidyr:pivot_longer]{tidyr::pivot_longer} function.
}
\examples{
exampleData = get_exampleData()
# the measure of mitochondrial mass - the x-axis of the 2D mito plot
mitochan = "VDAC"
# all channels available in the dataset
channelsAll = unique(exampleData[,"Channel"])
# remove mitochan from the channels of interest
channels = channelsAll[ channelsAll!=mitochan ]

sbj = unique(exampleData$sampleID)
ctrlID = grep("C", sbj, value=TRUE )
pts = grep("C", sbj, value=TRUE, invert=TRUE)

chan = channels[1]
pat = pts[1]

data_mat = getData_mats(exampleData, channels=c(mitochan, chan), ctrlID=ctrlID, pts=pat)

}
